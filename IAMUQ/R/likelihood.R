#' Log-density for the expert assessment of GWP per-capita growth.
#'
#' \code{log_exp_gwp} returns the log-density for the expert assessment of
#'    GWP per-capita growth from Christensen et al (2018), which is used in
#'    probabilistic inversion.
#'
#' This function uses the global per-capita growth trimmed mean (normal)
#'  distribution from 2010 to 2100 from Christensen et al (2018). It
#'  evaluates the density value of the model output based on this reference
#'  distribution.
#'
#' @param model_out Data frame of model output (from \code{\link{run_model}
#' }).
#' @return Log-density value of the model average GWP per-capita growth rate.
log_exp_gwp <- function(model_out) {
  # set parameter values for expert assessment distribution
  mu=2.54 # mean on percentage scale
  sigma=1.07 # sd on percentage scale

  # compute per-capita growth rates from model output
  gwp_rt <- avg_gwp_rate(model_out$P, model_out$Q, yrs=model_out$year, start=2010, end=2100)
  
  # compute and return log-likelihood of growth rate given expert assessment
  # distribution parameters are on a percentage scale, so multiply rate by 100
  dnorm(gwp_rt * 100, mean=mu, sd=sigma, log=TRUE)
}

#' Log-density for the expert assessment of CO2 emissions in 2100.
#'
#' \code{log_exp_co2} returns the log-density for the expert assessment of
#'    CO2 emissions in 2100 from Ho et al (2019), which is used in
#'    probabilistic inversion. This
#'
#' This function uses a normal distribution fit to the median 25% and 75%
#'  percentiles of experts who did not include negative emissions levels in
#'  their central 90% interval. It evaluates the density value of the model
#'  output based on this reference distribution.
#'
#' @param model_out Data frame of model output (from \code{\link{run_model}
#' }).
#' @return Log-density value of the model average GWP per-capita growth rate.
log_exp_co2 <- function(model_out) {
  # set parameter values for expert assessment distribution
  mu=23.1 # mean
  sigma=9 # sd on percentage scale

  # get CO2 emissions level in 2100 from model output
  co2_2100 <- model_out$C[model_out$year == 2100]
  
  # compute and return log-likelihood of CO2 emissions given expert assessment
  dnorm(co2_2100, mean=mu, sd=sigma, log=TRUE)
}
  
#' Log-prior density for the provided parameter values
#'
#' \code{log_pri} returns the log-prior density for the provided parameter
#'  values, based on the provided list of prior distributions.
#'
#' The provided prior distributions (which should be in the list form
#'  generated by \code{\link{create_prior_list}}) are treated as independent
#'  prior distributions, so that the joint log-prior density is the sum of
#'  the individual log-prior densities.
#'
#' @param pars Numeric vector of parameter values. These parameters must
#'  include all of the model parameters listed in Table S1 and the
#'  statistical parameters listed in Table S2 of Srikrishnan &
#'  Keller (2019), with Greek letters spelled out: \itemize{
#'  \item psi1, the population growth rate;
#'  \item psi2, the population half-saturation constant;
#'  \item psi3, the population carrying capacity;
#'  \item P0, the initial population in year \code{start};
#'  \item lambda, the elasticity of production with respect to labor (must
#'  be less than 1);
#'  \item s, the savings rate;
#'  \item delta, the capital depreciation rate (must be less than s);
#'  \item alpha, the rate of technological progress for total factor
#'  productivity;
#'  \item As, the saturation level of total factor productivity;
#'  \item pi, the labor participation rate (must be less than 1);
#'  \item A0, the initial total factor productivity in year \code{start};
#'  \item rho2, the carbon emissions intensity of technology 2;
#'  \item rho3, the carbon emissions intensity of technology 3;
#'  \item tau2, the half-saturation year of technology 2;
#'  \item tau3, the half-saturation year of technology 3;
#'  \item tau4, the half-saturation year of technology 4;
#'  \item kappa, the rate of technological penetration;
#'  \item aij, for $i,j=1, 2, 3$, the elements of the VAR cefficient matrix
#'  (only when using a VAR model for the likelihood structure);
#'  \item sigma_pop, the variance of the VAR or normal innovations for
#'  population;
#'  \item sigma_prod, the variance of the VAR or normal innovations for
#'  economic output;
#'  \item sigma_emis, the variance of the VAR or normal innovations for
#'  emissions;
#'  \item eps_pop, the variance of the observation errors for population
#'  (only when using a VAR model for the likelihood structure);
#'  \item eps_prod, the variance of the observation errors for economic
#'  output (only when using a VAR model for the likelihood structure);
#'  \item eps_emis, the variance of the observation errors for emissions.
#'  (only when using a VAR model for the likelihood structure);
#'  }
#' @param parnames Character vector of parameter names. These names should
#'  align with the values in \code{pars}, but they don't need to be in any
#'  particular order otherwise.
#' @param priors Named list of priors, with names containing all of the
#'  elements in \code{parnames}. \code{priors} is best created using
#'  '\code{\link{create_prior_list}}, but each element must be a list
#'  containing: \itemize{
#'  \item dens.fun, (string) function name for evaluating the density
#'  \item ..., other named parameters required for evaluation of
#'  \code{dens.fun}
#'  }
#' @return Joint log-prior density value parameters based on the given
#'  priors.
#' @export
log_pri <- function(pars, parnames, priors) {
  
  # this function evaluates the log-prior density for a given parameter
  log_dens <- function(name) {
    val <- pars[match(name, parnames)]
    # if we use a truncated normal prior, need to manually take the log
    if (priors[[name]][['type']] == 'truncnorm') {
      dens <- do.call(match.fun(priors[[name]][['dens.fun']]),
                      c(list(x=val),
                      priors[[name]][-which(names(priors[[name]]) %in% c('type', 'dens.fun', 'quant.fun', 'rand.fun'))])
              )
      log(dens)
    } else {
      do.call(match.fun(priors[[name]][['dens.fun']]),
              c(list(x=val, log=TRUE),
                priors[[name]][-which(names(priors[[name]]) %in% c('type', 'dens.fun', 'quant.fun', 'rand.fun'))])
             )
    }
  }
  # evaluate log-prior densities for each parameter
  lp <- vapply(parnames, log_dens, numeric(1))
  
  # return sum of log-priors
  sum(lp)
}

#' Check if parameter values satisfy prior constraints
#'
#' \code{check_param_constraints} checks if the parameter values specify
#'  constraints which are specified ahead of time.
#'
#' The specified constraints are (for the parameters passed to
#'  \code{\link{log_post}}): \itemize{
#'  \item delta < s;
#'  \item rho1 >= rho2;
#'  \item tau2 <= tau3 <= <= tau4;
#'  \item eigenvalues of the VAR coefficient matrix $A$ are <= 1 (for VAR
#'  residual model).
#'  }
#'
#' @param pars Numeric vector of parameter values. These parameter values are the same that are passed to \code{\link{log_post}}.
#' @param parnames Character vector of parameter names. These names should
#'  align with the values in \code{pars}, but they don't need to be in any
#'  particular order otherwise.
#' @return Boolean value corresponding to if the parameter values satisfied
#'  the given constraints.
check_param_constraints <- function(pars, parnames) {
  # read in parameter values
  delta <- pars[match('delta', parnames)]
  s <- pars[match('s', parnames)]
  pi <- pars[match('pi', parnames)]
  rho <- pars[match(c('rho2', 'rho3'), parnames)]
  tau <- pars[match(c('tau2', 'tau3', 'tau4'), parnames)]
  # check if the eigenvalues of the VAR coefficient matrix are within the unit circle (for stability of the VAR process)
  eig_flag <- TRUE
  if ('a_21' %in% parnames) {
    a <- pars[match(c('a_11', 'a_21', 'a_31', 'a_12', 'a_22', 'a_23', 'a_13', 'a_32', 'a_33'), parnames)]
    ev <- eigen(matrix(a, ncol=sqrt(length(a)), nrow=sqrt(length(a))))$values
    eig_flag <- all(vapply(ev, abs, numeric(1)) <= 1)
  }
  
  (delta < s) && (s < 1) && (pi < 1) && (rho[1] >= rho[2]) && (all(tau == cummax(tau))) && eig_flag
  
}

#' Check if model output satisfies the fossil fuel resource constraint.
#'
#' \code{check_fossil_constraint} checks if the emissions output is within
#'  the fossil fuel resource limit.
#'
#' This model assumes that there is a finite limit of Gt C that are
#'  associated with fossil fuel emissions. \code{check_fossil_constraint}
#'  checks if that constraint is satisfied by the model output.
#'
#' @param model_out Data frame produced by the model.
#' @param start First year for the fossil constraint.
#' @param end Last year for the fossil constraint.
#' @param thresh Fossil fuel resource constraint value (in Gt C).
#' @return Boolean value corresponding to if the model output satisfies the
#'  constraint.
check_fossil_constraint <- function(model_out, start=1700, end=2500, thresh=6000) {
  fossil_tot <- cum_co2(emis=model_out$C, yrs=model_out$year, start, end)
  if (is.na(fossil_tot)) {
    FALSE
  } else {
    fossil_tot <= thresh
  }
}

#' Check the tech penetration constraints.
#'
#' \code{check_penetration_constraints} check whether the simulation results pass the technological penetration constraints.
#'
#' The default priors for the technological substitution process are quite broad, so this check helps to constrain the range of outcomes to reflect more realistic dynamics.
#'
#' @param model_out Data frame produced by the model.
#' @param years Numeric vector of years for which the constraint is defined. By default this is \code{NA}, as the constraint is turned off. In principle the function should not be called if \code{years=NA}.
#' @param windows List specifying the windows for each technology at each year. Each element of the list should correspond to a year set in \code{years}. The windows should be specified in a 2x3 matrix where the rows are the lower and upper bounds and the columns correspond to the high-emitting technology, the low-emitting technology, and the zero-emissions technology. If a particular technology is not used in the constraint, set the corresponding row values as \code{NA}. The pre-industrial technology is ignored. By default this has a value of \code{NA}, as the constraint is turned off. An error will be returned if the format of this list doesn't match the specification and the number of years.
#' @return Boolean value corresponding to whether the simulation passes the constraint.
check_penetration_constraints <- function(model_out, years=NA, windows=NA) {
  # if years = NA, just return TRUE if this somehow got called.
  if (is.na(years)) {
    return TRUE
  }
  # throw an error if the number of years doesn't match the number of provided windows.
  if (length(years) != length(windows)) {
    stop("Number of constraint years does not match specified windows")
  }
  # throw an error if the dimension of the first window is not correct
  if (isTRUE(all.equal(dim(windows[[1]]), c(2, 3)))) {
    stop("Window data is not specified properly")
  }
  # if we got past that, check the constraints for each year
  # get the energy mix for each specified year
  tech_pen_colnames <- c('Frac_FossilHi', 'Frac_FossilLo', 'Frac_NonFossil')
  tech_shares <- model_out[model_out$year %in% years, tech_pen_colnames]
  # split tech shares into a list for purposes of comparison with the windows
  tech_list <- split(tech_shares, rep(1:nrow(tech_shares), times=ncol(tech_shares)))
  # sort years so they're the same order as the filtered model output
  sort_idx <- order(years)
  windows_sorted <- windows[sort_idx]
  # compare tech shares to the bounds for each year
  pass_const_yr <- mapply(function(x, bsd) all(x >= bds[1,] & x <= bds[2,], na.rm=TRUE), tech_list, windows_sorted)
  all(pass_const_yr) # return true only if all constraints were passed
}  

#' Calculate model residuals.
#'
#' \code{residuals} computes the model residuals relative to the data.
#'
#' @param model_out Data frame produced by model run, with columns 'year',
#'  P' (population), 'Q' (production), and 'C' (emissions).
#' @param dat List of data frames of data. List should have names 'pop'
#'  (population), 'prod' (production), and 'emissions,' and each data frame
#'  should have two columns, 'year' and 'value'.
#' @return List of model residuals, with the same names as the \code{dat}.
#' @export
residuals <- function(model_out, dat) {
  # compute residuals for each output
  r <- list()
  pop <- merge(dat[['pop']], model_out[, c('year', 'P')], by='year')
  r[['pop']] <- log(pop$value) - log(pop$P)
  prod <- merge(dat[['prod']], model_out[, c('year', 'Q')], by='year')
  r[['prod']] <- log(prod$value) - log(prod$Q)
  emis <- merge(dat[['emissions']], model_out[, c('year', 'C')], by='year')
  r[['emissions']] <- log(emis$value) - log(emis$C)
  
  # return residuals
  r
}

#' Compute the log-likelihood under the assumption of independently and
#'  identically Gaussian distributed residuals.
#'
#' \code{log_lik_iid} assumes that the model residuals are independently and
#'  identically distributed according to a normal distribution. Additionally,
#'  the model residuals are also independent of each other. It also checks
#'  if the model output satisfies a fossil fuel constraint, and returns
#'  -infinity if it does not.
#'
#' @param pars Numeric vector of parameter values. These parameters must
#'  include all of the model parameters listed in Table S1 and the
#'  statistical parameters listed in Table S2 of Srikrishnan &
#'  Keller (2019), with Greek letters spelled out: \itemize{
#'  \item psi1, the population growth rate;
#'  \item psi2, the population half-saturation constant;
#'  \item psi3, the population carrying capacity;
#'  \item P0, the initial population in year \code{start};
#'  \item lambda, the elasticity of production with respect to labor (must
#'  be less than 1);
#'  \item s, the savings rate;
#'  \item delta, the capital depreciation rate (must be less than s);
#'  \item alpha, the rate of technological progress for total factor
#'  productivity;
#'  \item As, the saturation level of total factor productivity;
#'  \item pi, the labor participation rate (must be less than 1);
#'  \item A0, the initial total factor productivity in year \code{start};
#'  \item rho2, the carbon emissions intensity of technology 2;
#'  \item rho3, the carbon emissions intensity of technology 3;
#'  \item tau2, the half-saturation year of technology 2;
#'  \item tau3, the half-saturation year of technology 3;
#'  \item tau4, the half-saturation year of technology 4;
#'  \item kappa, the rate of technological penetration;
#'  \item sigma_pop, the variance of the innovations for population;
#'  \item sigma_prod, the variance of the innovations for economic output
#'  ;
#'  \item sigma_emis, the variance of the innovations for emissions;
#'  }
#' @param parnames Character vector of parameter names. These names should
#'  align with the values in \code{pars}, but they don't need to be in any
#'  particular order otherwise.
#' @param model_out Data frame produced by model run, with columns 'year',
#'  P' (population), 'Q' (production), and 'C' (emissions).
#' @param dat List of data frames of data. List should have names 'pop'
#'  (population), 'prod' (production), and 'emissions,' and each data frame
#'  should have two columns, 'year' and 'value'.
#' @param thresh Numeric value setting the fossil fuel resource constraint.
#' @param ff_const_yrs Numeric vector setting the years over which the fossil
#'  fuel constraint should be evaluated. This can be a full sequence or a
#'  vector with the start and end years.
#' @param hoyrs Integer vector of years that should be held out from the
#'  likelihood function computation.
#' @return Numeric value for the log-likelihood of the parameters given the
#'  data and the fossil fuel constraint value.
#' @export
log_lik_iid <- function(pars, parnames, model_out, dat, thresh=6000, ff_const_yrs=1700:2500, hoyrs=NULL) {
  # check for fossil fuel constraint
  if (!check_fossil_constraint(model_out, start=ff_const_yrs[1], end=ff_const_yrs[length(ff_const_yrs)], thresh=thresh)) {
    return(-Inf)
  }
  
  # remove held out data if there is any and compute residuals
  if (length(hoyrs) > 0) {
    d <- lapply(dat, function(l) l[-which(l$year %in% hoyrs)])
    r <- residuals(model_out, d)
  } else {
    r <- residuals(model_out, dat)
  }
  
  # extract likelihood parameters
  sigma <- pars[match(c('sigma_pop', 'sigma_prod', 'sigma_emis'), parnames)]
  names(sigma) <- c('pop', 'prod', 'emissions')
  # compute log-likelihoods
  log_lik <- function(datname) {
    sum(dnorm(r[[datname]], mean = 0, sd = sigma[datname], log = TRUE))
  }
  # return sum of log-likelihood across data
  sum(vapply(names(sigma), log_lik, numeric(1)))
}

#' Compute the log-likelihood under the assumption of residuals jointly
#'  distributed according to a VAR(1) model.
#'
#' \code{log_lik_var} assumes that the model residuals are jointly
#'  distributed according to a vector autoregressive model of order 1 (VAR(1
#'  )). It also checks if the model output satisfies a fossil fuel constraint
#'  , and returns -infinity if it does not.
#'
#' @param pars Numeric vector of parameter values. These parameters must
#'  include all of the model parameters listed in Table S1 and the
#'  statistical parameters listed in Table S2 of Srikrishnan &
#'  Keller (2019), with Greek letters spelled out: \itemize{
#'  \item psi1, the population growth rate;
#'  \item psi2, the population half-saturation constant;
#'  \item psi3, the population carrying capacity;
#'  \item P0, the initial population in year \code{start};
#'  \item lambda, the elasticity of production with respect to labor (must
#'  be less than 1);
#'  \item s, the savings rate;
#'  \item delta, the capital depreciation rate (must be less than s);
#'  \item alpha, the rate of technological progress for total factor
#'  productivity;
#'  \item As, the saturation level of total factor productivity;
#'  \item pi, the labor participation rate (must be less than 1);
#'  \item A0, the initial total factor productivity in year \code{start};
#'  \item rho2, the carbon emissions intensity of technology 2;
#'  \item rho3, the carbon emissions intensity of technology 3;
#'  \item tau2, the half-saturation year of technology 2;
#'  \item tau3, the half-saturation year of technology 3;
#'  \item tau4, the half-saturation year of technology 4;
#'  \item kappa, the rate of technological penetration;
#'  \item aij, for $i,j=1, 2, 3$, the elements of the VAR cefficient matrix;
#'  \item sigma_pop, the variance of the VAR innovations for population;
#'  \item sigma_prod, the variance of the VAR innovations for economic output
#'  ;
#'  \item sigma_emis, the variance of the VAR innovations for emissions;
#'  \item eps_pop, the variance of the observation errors for population;
#'  \item eps_prod, the variance of the observation errors for economic
#'  output;
#'  \item eps_emis, the variance of the observation errors for emissions.
#'  }
#' @param parnames Character vector of parameter names. These names should
#'  align with the values in \code{pars}, but they don't need to be in any
#'  particular order otherwise.
#' @param model_out Data frame produced by model run, with columns 'year',
#'  P' (population), 'Q' (production), and 'C' (emissions).
#' @param dat List of data frames of data. List should have names 'pop'
#'  (population), 'prod' (production), and 'emissions,' and each data frame
#'  should have two columns, 'year' and 'value'.
#' @param thresh Numeric value setting the fossil fuel resource constraint.
#' @param ff_const_yrs Numeric vector setting the years over which the fossil
#'  fuel constraint should be evaluated. This can be a full sequence or a
#'  vector with the start and end years.
#' @param hoyrs Integer vector of years that should be held out from the
#'  likelihood function computation.
#' @return Numeric value for the log-likelihood of the parameters given the
#'  data and the fossil fuel constraint value.
#' @export
log_lik_var <- function(pars, parnames, model_out, dat, thresh=6000, ff_const_yrs=1700:2500, hoyrs=NULL) {
  # check fossil fuel constraint
  if (!check_fossil_constraint(model_out, start=ff_const_yrs[1], end=ff_const_yrs[length(ff_const_yrs)], thresh=thresh)) {
    return(-Inf)
  }
  
  # remove held out data if there is any, find indices for removal from the covariance matrix, and compute residuals
  if (length(hoyrs) > 0) {
    d <- lapply(dat, function(l) l[-which(l$year %in% hoyrs), ]) # remove held out data
    hoyridx <- which(dat[[1]]$year %in% hoyrs) # find indices of held out years
    # find covariance matrix indices of held out data
    hoidx <- numeric(0)
    for (i in 1:length(dat)) {
      hoidx <- c(hoidx, length(dat)*(hoyridx-1)+i)
    }
    # compute residuals
    r <- residuals(model_out, d)
  } else {
    # just compute residuals
    r <- residuals(model_out, dat)
    hoidx <- numeric(0) # no held-out data
  }
  
  # create vectorized residual vector
  r_vec <- as.numeric(matrix(do.call(rbind,r), nrow=1))
  
  # extract likelihood parameters
  a <- pars[match(c('a_11', 'a_21', 'a_31', 'a_12', 'a_22', 'a_32', 'a_13', 'a_23', 'a_33'), parnames)] # VAR model error coefficient
  sigma <- pars[match(c('sigma_pop', 'sigma_prod', 'sigma_emis'), parnames)] # AR model error sd
  names(sigma) <- c('pop', 'prod', 'emissions')
  eps <- pars[match(c('eps_pop', 'eps_prod', 'eps_emis'), parnames)] # observation error coefficient
  names(eps) <- c('pop', 'prod', 'emissions')
  #  eps2 <- pars[match(c('eps2_pop', 'eps2_prod', 'eps2_emis'), parnames)] # observation error coefficient
  
  # construct VAR coefficient matrix
  A <- matrix(a, nrow=length(dat), ncol=length(dat))
   
  # compute covariance matrix of the residuals for each time
  W <- diag(sigma)  # construct covariance matrix of the innovations
  Sigma_x_vec <- solve(diag(1, nrow(A)^2) - kronecker(A, A)) %*% as.numeric(W)
  Sigma_x <- matrix(Sigma_x_vec, nrow=nrow(A), ncol=ncol(A))
  
  # compute powers of A for autocovariance matrix computation
  n <- nrow(dat[[1]])

  H <- abs(outer(1:n, 1:n, '-')) # matrix of indices for blocks as they should be combined
  D <- diag(eps) # matrix of observation error variances
  
  Sigma <- cov_mat(A, Sigma_x, D, H) # generate covariance matrix
  # if there are held out yrs, remove their components from Sigma
  if (length(hoidx) > 0) {
    Sigma <- Sigma[-hoidx, -hoidx]
  }
  
  # compute log-likelihood of residuals with respect to zero mean
  mvtnorm::dmvnorm(r_vec, sigma=Sigma, log=TRUE)
}

#' Log-posterior density for the provided parameter values given the data
#'
#' \code{log_post} returns the log-posterior density for the provided
#'  parameter values, based on the provided list of prior distributions, the
#'  data, the fossil fuel constraint, and the desired likelihood structure.
#'
#' The provided prior distributions should be in the list form
#'  generated by \code{\link{create_prior_list}}.
#'
#' @param pars Numeric vector of parameter values. These parameters must
#'  include all of the model parameters listed in Table S1 and the
#'  statistical parameters listed in Table S2 of Srikrishnan &
#'  Keller (2019), with Greek letters spelled out: \itemize{
#'  \item psi1, the population growth rate;
#'  \item psi2, the population half-saturation constant;
#'  \item psi3, the population carrying capacity;
#'  \item P0, the initial population in year \code{start};
#'  \item lambda, the elasticity of production with respect to labor (must
#'  be less than 1);
#'  \item s, the savings rate;
#'  \item delta, the capital depreciation rate (must be less than s);
#'  \item alpha, the rate of technological progress for total factor
#'  productivity;
#'  \item As, the saturation level of total factor productivity;
#'  \item pi, the labor participation rate (must be less than 1);
#'  \item A0, the initial total factor productivity in year \code{start};
#'  \item rho2, the carbon emissions intensity of technology 2;
#'  \item rho3, the carbon emissions intensity of technology 3;
#'  \item tau2, the half-saturation year of technology 2;
#'  \item tau3, the half-saturation year of technology 3;
#'  \item tau4, the half-saturation year of technology 4;
#'  \item kappa, the rate of technological penetration;
#'  \item aij, for $i,j=1, 2, 3$, the elements of the VAR cefficient matrix
#'  (only when using a VAR model for the likelihood structure);
#'  \item sigma_pop, the variance of the VAR or normal innovations for
#'  population;
#'  \item sigma_prod, the variance of the VAR or normal innovations for
#'  economic output;
#'  \item sigma_emis, the variance of the VAR or normal innovations for
#'  emissions;
#'  \item eps_pop, the variance of the observation errors for population
#'  (only when using a VAR model for the likelihood structure);
#'  \item eps_prod, the variance of the observation errors for economic
#'  output (only when using a VAR model for the likelihood structure);
#'  \item eps_emis, the variance of the observation errors for emissions.
#'  (only when using a VAR model for the likelihood structure);
#'  }
#' @param parnames Character vector of parameter names. These names should
#'  align with the values in \code{pars}, but they don't need to be in any
#'  particular order otherwise.
#' @param priors Named list of priors, with names containing all of the
#'  elements in \code{parnames}. \code{priors} is best created using
#'  '\code{\link{create_prior_list}}, but each element must be a list
#'  containing: \itemize{
#'  \item dens.fun, (string) function name for evaluating the density
#'  \item ..., other named parameters required for evaluation of
#'  \code{dens.fun}
#'  }
#' @param dat List of data frames of data. List should have names 'pop'
#'  (population), 'prod' (production), and 'emissions,' and each data frame
#'  should have two columns, 'year' and 'value'.
#' @param lik_fun Character string with the name of the desired likelihood
#'  function (provided functions are \code{log_lik_iid} and
#'  '\code{log_lik_var}).
#' @param exp_gwp Boolean: should the provided expert assessment of average
#'  GWP growth from 2010-2100 (\code{log_exp_gwp}) be inverted for additional
#'  prior structure?
#' @param exp_co2 Boolean: should the provided expert assessment of CO2
#'  emissions in 2100 (\code{log_exp_co2}) be inverted for additional
#'  prior structure?
#' @param thresh Numeric value setting the fossil fuel resource constraint.
#' @param ff_const_yrs Numeric vector setting the years over which the fossil
#'  fuel constraint should be evaluated. This can be a full sequence or a
#'  vector with the start and end years.
#' @param hoyrs Integer vector of years that should be held out from the
#'  likelihood function computation.
#' @return Numeric value for the log-posterior of the parameters given the
#'  priors, the data and the fossil fuel constraint value.
#' @export
log_post <- function(pars, parnames, priors, dat, lik_fun, exp_gwp=FALSE, exp_co2=FALSE, thresh=6000, ff_const_yrs=1700:2500, hoyrs=NULL) {
  
  # check for parameter constraints and return -Inf if not satisfied
  if (!check_param_constraints(pars, parnames))  {
    return(-Inf)
  }
  
  # compute log-priors
  lpri <- log_pri(pars, parnames, priors)
  # if log-prior density is -Inf, no need to evaluate likelihood
  if (lpri == -Inf) {
    return(-Inf)
  }
  # run model to end date, which is 2500
  yr <- 1700:2500
  model_out <- run_model(pars, parnames, start=1700, end=2500)
  ll <- match.fun(lik_fun)(pars, parnames, model_out, dat, thresh=thresh, ff_const_yrs=ff_const_yrs, hoyrs=hoyrs) # evaluate likelihood
  
  lpost <- lpri + ll # store sum of log-likelihood and log-prior

  # if expert assessment inversion is included, add log-expert assessment density
  if (exp_gwp) {
    lpost <- lpost + log_exp_gwp(model_out)
  }
  if (exp_co2) {
    lpost <- lpost + log_exp_co2(model_out)
  }

  lpost # return log-posterior vlaue
}

#' Negative log-posterior density for the provided parameter values given the
#'  data.
#'
#' \code{neg_log_post} returns the negative of the log-posterior density
#'  value for the provided parameter values, based on the provided list of
#'  prior distributions, the data, the fossil fuel constraint, and the
#'  desired likelihood structure. It is intended for use with an objective
#'  -minimizing optimization function such as \code{DEoptim}.
#'
#' The provided prior distributions should be in the list form
#'  generated by \code{\link{create_prior_list}}.
#'
#' @param pars Numeric vector of parameter values. These parameters must
#'  include all of the model parameters listed in Table S1 and the
#'  statistical parameters listed in Table S2 of Srikrishnan &
#'  Keller (2019), with Greek letters spelled out: \itemize{
#'  \item psi1, the population growth rate;
#'  \item psi2, the population half-saturation constant;
#'  \item psi3, the population carrying capacity;
#'  \item P0, the initial population in year \code{start};
#'  \item lambda, the elasticity of production with respect to labor (must
#'  be less than 1);
#'  \item s, the savings rate;
#'  \item delta, the capital depreciation rate (must be less than s);
#'  \item alpha, the rate of technological progress for total factor
#'  productivity;
#'  \item As, the saturation level of total factor productivity;
#'  \item pi, the labor participation rate (must be less than 1);
#'  \item A0, the initial total factor productivity in year \code{start};
#'  \item rho2, the carbon emissions intensity of technology 2;
#'  \item rho3, the carbon emissions intensity of technology 3;
#'  \item tau2, the half-saturation year of technology 2;
#'  \item tau3, the half-saturation year of technology 3;
#'  \item tau4, the half-saturation year of technology 4;
#'  \item kappa, the rate of technological penetration;
#'  \item aij, for $i,j=1, 2, 3$, the elements of the VAR cefficient matrix
#'  (only when using a VAR model for the likelihood structure);
#'  \item sigma_pop, the variance of the VAR or normal innovations for
#'  population;
#'  \item sigma_prod, the variance of the VAR or normal innovations for
#'  economic output;
#'  \item sigma_emis, the variance of the VAR or normal innovations for
#'  emissions;
#'  \item eps_pop, the variance of the observation errors for population
#'  (only when using a VAR model for the likelihood structure);
#'  \item eps_prod, the variance of the observation errors for economic
#'  output (only when using a VAR model for the likelihood structure);
#'  \item eps_emis, the variance of the observation errors for emissions.
#'  (only when using a VAR model for the likelihood structure);
#'  }
#' @param parnames Character vector of parameter names. These names should
#'  align with the values in \code{pars}, but they don't need to be in any
#'  particular order otherwise.
#' @param priors Named list of priors, with names containing all of the
#'  elements in \code{parnames}. \code{priors} is best created using
#'  '\code{\link{create_prior_list}}, but each element must be a list
#'  containing: \itemize{
#'  \item dens.fun, (string) function name for evaluating the density
#'  \item ..., other named parameters required for evaluation of
#'  \code{dens.fun}
#'  }
#' @param dat List of data frames of data. List should have names 'pop'
#'  (population), 'prod' (production), and 'emissions,' and each data frame
#'  should have two columns, 'year' and 'value'.
#' @param lik_fun Character string with the name of the desired likelihood
#'  function (provided functions are \code{log_lik_iid} and
#'  '\code{log_lik_var}).
#' @param exp_gwp Boolean: should the provided expert assessment of average
#'  GWP growth from 2010-2100 (\code{log_exp_gwp}) be inverted for additional
#'  prior structure?
#' @param exp_co2 Boolean: should the provided expert assessment of CO2
#'  emissions in 2100 (\code{log_exp_co2}) be inverted for additional
#'  prior structure?
#' @param thresh Numeric value setting the fossil fuel resource constraint.
#' @param ff_const_yrs Numeric vector setting the years over which the fossil
#'  fuel constraint should be evaluated. This can be a full sequence or a
#'  vector with the start and end years.
#' @param hoyrs Integer vector of years that should be held out from the
#'  likelihood function computation.
#' @return Numeric value for the log-posterior of the parameters given the
#'  priors, the data and the fossil fuel constraint value.
#' @export
neg_log_post <- function(pars, parnames, priors, dat, lik_fun, exp_gwp=FALSE, exp_co2=FALSE, thresh=6000, ff_const_yrs=1700:2500, hoyrs=NULL) {

  # evaluate log-likelihood
  lp <- log_post(pars,parnames, priors, dat, lik_fun, exp_gwp, thresh=thresh, ff_const_yrs=ff_const_yrs, hoyrs=hoyrs)
  # return negative log-likelihood
  -1*lp
}


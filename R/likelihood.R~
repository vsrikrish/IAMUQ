##########################################################
# likelihood.R                                           #
#   This file contains the code for the likelihood       #
#     functions                                          #
##########################################################

R_path <- 'R'
source(file.path(R_path, 'model.R'))

log_pri <- function(pars, parnames, priors) {
   
   # this function evaluates the log-prior density for a given parameter
   log_dens <- function(par) {
      val <- pars[match(par, parnames)]
      do.call(match.fun(priors[[par]][['dens.fun']]),
                  c(list(x=val, log=TRUE), priors[['P0']][-c(1,2)])
      )
    }
  
  
  # evaluate log-prior densities for each parameter
  lp <- vapply(parnames, log_dens, numeric(1))
  
  # return sum of log-priors
  sum(lp)
}

# this function evaluates the log-likelihood under the assumption of iid residuals
log_lik_iid <- function(pars, parnames, dat, start = 1700, end = 2017) {
  # evaluate model output
  model_out <- mod(pars, parnames, start = start, end = end)
  
  # compute residuals for each output
  r <- list()
  pop <- merge(dat[['pop']], model_out[, c('year', 'P')], by='year')
  r[['pop']] <- pop$P - pop$pop
  prod <- merge(dat[['prod']], model_out[, c('year', 'Q')], by='year')
  r[['prod']] <- prod$Q - prod$prod
  emis <- merge(dat[['emissions']], model_out[, c('year', 'C')], by='year')
  r[['emissions']] <- emis$C - emis$emissions
  
  # extract likelihood parameters
  sigma <- pars[match(c('sigma_pop', 'sigma_prod', 'sigma_emis'), parnames)]
  names(sigma) <- c('pop', 'prod', 'emissions')
  # compute log-likelihoods
  log_lik <- function(datname) {
    sum(dnorm(r[[datname]], mean = 0, sd = sigma[datname], log = TRUE))
  }
  # return sum of log-likelihood across data
  sum(vapply(names(sigma), log_lik, numeric(1)))
}

log_lik_ar <- function(pars, parnames, dat, start = 1700, end = 2017) {
  # evaluate model output
  model_out <- mod(pars, parnames, start = start, end = end)
  
  # compute residuals for the log of each output
  r <- list()
  pop <- merge(dat[['pop']], model_out[, c('year', 'P')], by='year')
  r[['pop']] <- log(pop$pop) - log(pop$P)
  prod <- merge(dat[['prod']], model_out[, c('year', 'Q')], by='year')
  r[['prod']] <- log(prod$prod) - log(prod$Q)
  emis <- merge(dat[['emissions']], model_out[, c('year', 'C')], by='year')
  r[['emissions']] <- log(emis$emissions) - log(emis$C)
  
  # extract likelihood parameters
  a <- pars[match(c('a_pop', 'a_prod', 'a_emis'), parnames)] # AR coefficient
  names(a) <- c('pop', 'prod', 'emissions')
  eta <- pars[match(c('eta_pop', 'eta_prod', 'eta_emis'), parnames)] # AR error sd
  names(eta) <- c('pop', 'prod', 'emissions')
  # compute log-likelihoods
  log_lik <- function(datname) {
    res <- r[[datname]][-1] - a[datname] * r[[datname]][-length(r[[datname]])]
    sum(dnorm(res, mean = 0, sd = eta[datname], log = TRUE))
  }
  # return sum of log-likelihood across data
  sum(vapply(names(eta), log_lik, numeric(1)))
}

log_lik_mvar <- function(pars, parnames, dat, start = 1700, end = 2017) {
    
  library(mvtnorm)

  # evaluate model output
  model_out <- mod(pars, parnames, start = start, end = end)
  
  # compute residuals for the log of each output
  r <- list()
  pop <- merge(dat[['pop']], model_out[, c('year', 'P')], by='year')
  r[['pop']] <- log(pop$pop) - log(pop$P)
  prod <- merge(dat[['prod']], model_out[, c('year', 'Q')], by='year')
  r[['prod']] <- log(prod$prod) - log(prod$Q)
  emis <- merge(dat[['emissions']], model_out[, c('year', 'C')], by='year')
  r[['emissions']] <- log(emis$emissions) - log(emis$C)
  
  # extract likelihood parameters
  a <- pars[match(c('a_pop', 'a_prod', 'a_emis'), parnames)] # AR coefficient
  names(a) <- c('pop', 'prod', 'emissions')
  eta <- pars[match(c('eta_pop', 'eta_prod', 'eta_emis'), parnames)] # Cholesky diagonal terms
  rho <- pars[match(c('rho_1', 'rho_2', 'rho_3'), parnames)] # Cholesky off-diagonal terms
  
  # compute log-likelihood
  # compute the covariance matrix from the Cholesky factor
  L.vec <- c(eta[1], rho[1], rho[2], eta[2], rho[3], eta[3]) # assemble Cholesky factor parameters into a vector, based on column-wise assignment
  L <- matrix(0, nrow=length(names(a)), ncol=length(names(a)))
  L[which(lower.tri(L, diag=TRUE))] <- L.vec # construct the Cholesky factor
  Sigma <- L %*% t(L) # compute the covariance matrix
  
  # compute AR residuals for data series
  compute_ar_res <- function(datname) {
    r[[datname]][-1] - a[datname] * r[[datname]][-length(r[[datname]])]
  }
  res <- vapply(names(r), compute_ar_res, numeric(length(r[[1]])-1))
  
  # compute log-likelihood for each set of observations and return sum
  sum(apply(res, 1, dmvnorm, sigma = Sigma, log = TRUE))
}

neg_log_lik <- function(pars, parnames, dat, lik_fun) {
   # check for parameter constraints; if not satisfied, return Inf
   delta <- pars[match('delta', parnames)]
   s <- pars[match('s', parnames)]
   rho <- pars[match(c('rho2', 'rho3'), parnames)]
   tau <- pars[match(c('tau2', 'tau3', 'tau4'), parnames)]
   if ((delta >= s) || (rho[1] < rho[2]) || (any(tau != cummax(tau)))) {
     return(Inf)
   }

  # evaluate log-likelihood
  ll <- match.fun(lik_fun)(pars, parnames, dat)
  # return negative log-likelihood
  -1*ll
}

log_post <- function(pars, parnames, priors, dat, lik_fun) {
  # check for parameter constraints and return 0 if not satisfied
   delta <- pars[match('delta', parnames)]
   s <- pars[match('s', parnames)]
   lambda <- pars[match('lambda', parnames)]
   rho <- pars[match(c('rho2', 'rho3'), parnames)]
   if ((delta >= s) || (lambda > 1) || (lambda < 0) || (rho[1] < rho[2])) {
     return(0)
   }

  # compute log-priors
  lp <- log_pri(pars, parnames, dat)
  # if log-prior density is 0, no need to evaluate likelihood
  if (lp == 0) {
    return(0)
  }
  # evaluate likelihood
  ll <- match.fun(lik_fun)(pars, parnames, dat)
  # return sum of log-prior and log-likelihood
  lp + ll
}

}

## add iid normal noise
iid.sim <- function(N, sigma) {
  rnorm(N, mean=0, sd=sigma)
}

## add ar1 noise
# simulate stationary AR(1) process (approximate - faster, better convergence, and
# results not sensitive to use of this as opposed to exact AR1)
ar.sim <- function(N,rho1,sigma) {
    x <- rep(NA,N)
    if(length(sigma) > 1) {
        x[1] = rnorm(n=1,sd=sigma[1]/sqrt(1-rho1^2))
        for (i in 2:N) {
            x[i] <- rho1*x[i-1] + rnorm(1,sd=sigma[i])
        }
    } else {
        x[1] = rnorm(n=1,sd=sigma/sqrt(1-rho1^2))
        for (i in 2:N) {
            x[i] <- rho1*x[i-1] + rnorm(1,sd=sigma)
        }
    }
    x
}

## add VAR1 noise
# simulate stationary VAR(1) process
var.sim <- function(N, A, W, D) {
  x <- matrix(NA, nrow=ncol(A), ncol=N)
  
  Sigma_x_vec <- solve(diag(1, nrow(A)^2) - kronecker(A, A)) %*% as.numeric(W)
  Sigma_x <- matrix(Sigma_x_vec, nrow=nrow(A), ncol=ncol(A))
  
  x[,1] <- rmvnorm(n=1, sigma=Sigma_x)
  for (i in 2:N) {
    x[,i] <- A %*% x[,i-1] + t(rmvnorm(1, sigma=W)) + t(rmvnorm(1, sigma=D))
  }
  x
}

## simulate model output
sim_model <- function(pars, parnames, type, start=1700, end=2100) {
  # evaluate model
  model_out <- run_model(pars, parnames, start, end)[, c('year', 'P', 'Q', 'C')]
  # add simulated model discrepancy terms
  if (type != 'var') {
    # extract AR process parameters
    rho <- pars[match(c('a_11', 'a_22', 'a_33'), parnames)] # AR model error coefficient
    names(rho) <- c('P', 'Q', 'C')
    sigma <- pars[match(c('sigma_pop', 'sigma_prod', 'sigma_emis'), parnames)] # AR model error sd
    names(sigma) <- c('P', 'Q', 'C')
    discrepancy <- vapply(names(rho), function(n) match.fun(paste0(type, '.sim'))(length(start:end), rho[n], sigma[n]), numeric(length(start:end)))
    sim_out <- model_out[, c('P', 'Q', 'C')] + discrepancy
  } else if (type == 'var') {
    # extract VAR process parameters
    a <- pars[match(c('a_11', 'a_21', 'a_31', 'a_12', 'a_22', 'a_32', 'a_13', 'a_23', 'a_33'), parnames)] # VAR model error coefficient
    sigma <- pars[match(c('sigma_pop', 'sigma_prod', 'sigma_emis'), parnames)] # AR model error sd
    eps <- pars[match(c('eps_pop', 'eps_prod', 'eps_emis'), parnames)] # observation error coefficient
    
    # construct VAR coefficient matrix
    A <- matrix(a, nrow=length(sigma), ncol=length(sigma))
  
    W <- diag(sigma^2)  # construct covariance matrix of the innovations
    D <- diag(eps) # construct observation error matrix
    discrepancy <- var.sim(length(start:end), A, W, D)
    sim_out <- model_out[, c('P', 'Q', 'C')]) + discrepancy
  }
  data.frame(year=model_out[,'year'], sim_out)
}

## evaluate posterior predictive statistics

## compute annual average gdp per capita growth rate over some period
avg_gwp_rate <- function(model_out, start=2010, end=2100) {
  end_yrs <- model_out[model_out$year %in% c(start, end),] # we only need values from start and end years
  gwp_pc <- end_yrs$Q / end_yrs$P # compute per capita GWP
  exp((log(gwp_pc[2]) - log(gwp_pc[1]))/(end-start)) - 1 # compute average growth rate
}

## compute cumulative CO2 emissions over some period
cum_co2 <- function(model_out, start=2000, end=2100) {
  sum(model_out$C[model_out$year %in% start:end])
}